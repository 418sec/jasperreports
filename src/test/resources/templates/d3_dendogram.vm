<div id="element${configuration.element.hashCode()}" style="width: ${configuration.element.width}px; height: ${configuration.element.height}px;" ></div>


## Configure the javascript includes
${configuration.scripts.require( { "path": "scripts/d3/d3.v3.min.js", "name": "", "export": "d3", "key": "d3"},
                                 { "path": "scripts/d3/d3.layout.min.js", "name": "", "export": "", "key": "d3-layout"} )}


## Styles are included inline, but could actually either dynamically generated or included from an external css.
<style>

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}

</style>

<script class='jasperreports' type='text/javascript'>
        

        ## This is the main entry point function that transform an instanceData, which contains the 
        ## data to render, to the real chart.
        function renderComponentelement${configuration.element.hashCode()}(instanceData)
        {
                var data = { name: "" + instanceData.rootLabel , children: [] };

                // Build the tree...
                var series0 = instanceData.series[0];
                
                var currentCategory = "";
                for (var index = 0; index < series0.length; ++index) {
                    
                    var record = series0[index];
                    
                    if ( currentCategory != record.category )
                    {
                        currentCategory = record.category;
                        
                        var categoryObject = { name: currentCategory, children: [] };
                        
                        // populate sub categories
                        for (var index2 = 0; index2 < series0.length; ++index2) {
                            var subrecord = series0[index2];
                            if (subrecord.category == currentCategory)
                            {
                                categoryObject.children.push({ name: subrecord.subcategory, size: subrecord.value });
                            }
                        }
                        data.children.push( categoryObject );
                    }
                } 
                
                var w = instanceData.width,
                    h = instanceData.height;


                var cluster = d3.layout.cluster()
                        .size([h, w - 180]);



                var diagonal = d3.svg.diagonal()
                    .projection(function(d) { return [d.y, d.x]; });

                var vis = d3.select("#element" + instanceData.key ).append("svg:svg")
                    .attr("width", w)
                    .attr("height", h)
                  .append("svg:g")
                    .attr("transform", "translate(40, 0)");

                  var nodes = cluster.nodes(data);

                  var link = vis.selectAll("path.link")
                      .data(cluster.links(nodes))
                    .enter().append("svg:path")
                      .attr("class", "link")
                      .attr("d", diagonal);

                  var node = vis.selectAll("g.node")
                      .data(nodes)
                    .enter().append("svg:g")
                      .attr("class", "node")
                      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })

                  node.append("svg:circle")
                      .attr("r", 4.5);

                  node.append("svg:g")
                     .attr("transform", function(d) { return "translate(" + ((d.children) ? -7 : 7) + ",4)"; })
                      .append("svg:text")
                      .attr("text-anchor", function(d) { return d.children ? "end" : "start"; })
                      .text(function(d) { return d.name; });
        }


        ## The main function (renderComponentelementXXX) is invoked by requirejs and the component javascript module
        ## automatically. In case the environment is not using requirejs, which is what happens with a standard
        ## export outside jasperreports server or an interactive environment, we need to kick the rendering
        ## process manually by invoking renderComponentelementXXX  
        #if (!${configuration.isInteractiveViewer})
            renderComponentelement${configuration.element.hashCode()}(${configuration.instanceData});
        #end


       
</script>