<?xml version="1.0" encoding="UTF-8"?>

<sample>
  <name>chart_customizers</name>
  <title>Chart Customizers</title>
  <description>Shows how to use multiple chart customizers on the same chart</description>

  <mainFeature ref="chartcustomizers"/>
  <secondaryFeature name="charts" sample="charts" title="Charts"/>

  <!-- chartcustomizers -->
  
  <feature name="chartcustomizers" title="Multiple Chart Customizers">
    <description>
How to make various changes to a generated chart using the <a href="http://jfree.org/jfreechart/">JFreeChart API</a>,
using one or more chart customizer on the same report.
    </description>
    <since>6.3.1</since>
    <documentedBy>
      <author>
    	<name>Marco Orlandin</name>
    	<email>dejawho2@users.sourceforge.net</email>
      </author>
    </documentedBy>
    <content>
<b>Multiple Chart Customizers</b>
<br/>
<br/>
To provide full control over chart customization even when using the built-in chart 
component, JasperReports can make use of a  chart customizer implementation associated with the chart element. 
<br/>
The main limitation on using the chart customizers is that only one customizer for every report can be defined. To overcame
this limit a special customizer, the ProxyChartCustmomizer, has been defined. This new customizer does nothing on the chart
by its own, but it can load a series of customizer and execute them on the chart. Also allow to used the property value and 
property expressions of the chart to pass value to the executed customizers. The ProxyChartCustmizer can work with both the old
customizers and with the new Configurable Chart Customizer, that are the ones that uses the data from the chart properties as configuration.
<br/>
<br/>
To use the ProxyChartCustomizer:
<ul>
<li>The main customizer of the chart must be set to <b>net.sf.jasperreports.chartcustomizers.ProxyChartCutomizer</b></li>
<li>One or more properties that define the sub-customizers, with name like <b>chartcustomizer.customizer0.class</b>.
<br/>In this case the dot is a separator, and it is composed of three parts:
<ul>
<li>The first one, <b>chartcustomizer</b>, it is a standard prefix to declare a property for the ProxyChartCustmizer</li>
<li>The second one, <b>customizer0</b>, it is an unique key used to identify the properties of a specific customizer</li>
<li>The third one, <b>class</b>, is the name of the property. Typically this depend to which properties a customizer define and uses. The class
property however is mandatory for each customizer to be used by the ProxyChartCustomzier.</li>
</ul>
The class property for a specific customizer is always present and has as value the class of a customizer executed by the ProxyChartCustomizer.
</li>
<li>Optionally the properties to configure the sub-customizers. They can be both value property or expression property, in the last case they 
are resolved when the customizer is executed and having the chart as scope. The name of the property is similar to the class case, since also that
one was a property. So we will have the prefix <b>chartcustomizer</b>, the unique identifier of the customizer to which this property belong and the
property name. The value will be simply the value of the property
<br/>An example of the property with with value 10 for the customizer with identifier customizer0 will be something like <b>chartcustomizer.customizer0.width</b> and to the
property will be associated the value 10.
</li>
</ul>
<br/>
The sub-customizers when executed will receive all the parameters defined for them, and only that ones (so a sub-customizer has visibility only on the properties defined for it). The expression will 
be already resolved and the properties he receive will not have the prefix and the unique id, but only the property name. In this way a sub-customizer doens't need to worry about resolving expressions 
or knowing its identifier, it receive only a set or property with a simple name and a resolved value.
<br/>
Having an unique identifier for each customizer class allow to add more times the same customizer to the ProxyChartCustmizer and configure them with different set of property values. 
<br/>
<br/>
The use the configuration functionalities provided by the ProxyChartCustmizer a sub-customizer must implement a specific interface <b>net.sf.jasperreports.chartcustomizers.ConfigurableChartCustmizer</b>.
This will allow the ProxyChartCustmizer to set a map on the customizer class implementation containing all the properties defined for that customizer with paired with their resolved values.
<br/>
<br/>
<b>A Simple Configurable Chart Customizer Class Example</b>
<br/>
<br/>
When one implements the <api href="net/sf/jasperreports/engine/JRChartCustomizer.html">JRChartCustomizer</api> interface and the ConfigurableChartCustomizer interface, 
the methods which has to be implemented are:
<br/>
<br/>
<code>public void customize(JFreeChart chart, JRChart jasperChart);</code>
<br/>
<br/>
Which is the standard for every JRChartCustmizer and
<br/>
<br/>
<code>public void setConfiguration(Map&lt;String, String> properties);</code>
<br/>
<br/>
That will be used by the ProxyChartCustmizer to pass the value of the properties.
First, let's take a look at the StarShapeCustmizer class in the <code>src</code> directory:
<pre>
<![CDATA[
public class StarShapeCustomizer implements JRChartCustomizer, ConfigurableChartCustomizer {

	protected Map<String, String> configuration = null;
	
	public static final String SHAPE_WIDTH = "legendShapeWidth";
	
	public static final String SHAPE_HEIGHT = "legendShapeHeight";
	
	@Override
	public void customize(JFreeChart jfc, JRChart jasperChart) {
		if (jfc.getPlot() instanceof XYPlot){
            XYPlot plot = jfc.getXYPlot();
            if (plot.getRenderer() instanceof AbstractRenderer){
	            updateLegendItems(plot.getLegendItems(), (AbstractRenderer)plot.getRenderer());
            }
        }  else if (jfc.getPlot() instanceof CategoryPlot){
        	CategoryPlot plot = jfc.getCategoryPlot();
        	if (plot.getRenderer() instanceof AbstractRenderer){
	            updateLegendItems(plot.getLegendItems(), (AbstractRenderer) plot.getRenderer());
        	}
        }
	}

	protected Integer getWidth() {
		//read the property from the passed parameter
		return ChartCustomizerUtils.asInteger(configuration.get(SHAPE_WIDTH));
	}

	protected Integer getHeight() {
		//read the property from the passed parameter
		return ChartCustomizerUtils.asInteger(configuration.get(SHAPE_HEIGHT));
	}

	@Override
	public void setConfiguration(Map<String, String> properties) {
		//store the passed parameters
		this.configuration = properties;
	}
}
]]></pre>
    </content>
  </feature>

</sample>
